
class Options(object):
    def __init__(self, prime, degree_bounds, numpcs):
        self.prime = prime
        self.bounds = degree_bounds
        self.numpcs = numpcs

    def get_prime(self):
        return self.prime

    def get_bounds(self):
        return self.bounds

    def get_numpcs(self):
        return self.numpcs

opts = Options(5, 10, 2)

import random 
class Monomial(object):
    """terms is a list of tuples of the form (y, i) where y is a string
    "t" or "x" and i is a natural number. We assume terms of the form
    ("x",0) do not appear. Such terms are 1 in the dual steenrod
    algebra. An empty list is treated as (coeff * 1). 

    """
    @staticmethod
    def random(length):
        terms = []
        for i in range(length):
            randint = random.randrange(20)
            parity = random.randrange(2)
            if parity:
                terms.append(("t", randint))
            elif randint:
                terms.append(("x", randint))

        return Monomial( terms,  random.randrange(opts.get_prime()))
        
    def __init__(self, terms, coeff):
        self.terms = terms
        self.coeff = coeff

    def __getstate__(self):
        return {'terms' : self.terms,
                'coeff' : self.coeff}
        
    def __setstate__(self, _dict):
        self.terms = _dict['terms']
        self.coeff = _dict['coeff']

    def get_terms(self):
        return self.terms

    def get_coeff(self):
        return self.coeff % opts.get_prime()
    
    def get_degree(self):
        deg = 0
        wt = 0
        for term in self.terms:
            if term[0] == "x":
                deg += 2*(opts.prime**term[1] - 1) 
                wt += opts.prime**term[1] - 1
            elif term[0] == "t":
                deg += 2*opts.prime**term[1] - 1
                wt += opts.prime**term[1] - 1

    def copy(self):
        return copy.deepcopy(self)
                
    def __str__(self):
        mystr = ""
        mystr += str(self.get_coeff()) 
        if not self.terms:
            return mystr
        mystr += "."
        for term in self.terms:
            mystr += term[0] + str(term[1])
        return mystr

    def simplify(self):
        """
        Warning! Mutator!
        """
        newterms = sorted([ term for term in self.terms if term[0] == "x"], key=lambda term: term[1])
        # tauterms = [ term for term in self.terms if term[0] == "t"]
        tauindices = [ term[1] for term in self.terms if term[0] == "t"]
        newcoeff = self.coeff
        if repeats(tauindices):
            self.terms = []
            self.coeff = 0
        elif not self.get_coeff():
            self.terms = []
            self.coeff = 0
        else:
            tausorted = tauindices[:]
            tausorted.sort()
            perm = arePermsEqualParity(tauindices, tausorted)
            if not perm:
                self.coeff = -self.coeff
            newterms += [("t", x) for x in tausorted]
            self.terms = newterms

    def __mul__(self,other):
        """
        Does not mutate self or other. 
        Returns the product
        """
        prodterms = self.get_terms() + other.get_terms()
        prodcoeff = self.get_coeff() * other.get_coeff()
        prod = Monomial(prodterms, prodcoeff)
        prod.simplify()
        return prod

class Polynomial(object):
    """
    summands is a list of monomial objects
    """
    def __init__(self, summands):
        self.summands = summands

    def get_summands(self):
        return self.summands

    def homogeneous(self):
        degs = { mon.get_degree() for mon in self.get_summands() }
        if len(degs) > 1:
            return False
        else:
            return True

    def get_degree(self):
        if self.homogeneous():
            return self.get_summands()[0].get_degree()
        else:
            return False

    def __sum__(self, other):
        return Polynomial(self.get_summands() + other.get_summands())

    def __mul__(self, other):
        newsummands = []
        for mon1 in self.get_summands():
            for mon2 in other.get_summands():
                newsummands.append(mon1*mon2)
        return Polynomial(newsummands)
        
    def combine_monomials(self):
        """
        Mutator!
        """
        for mon in self.get_summands():
            mon.simplify()
        

        
def repeats(alist):
    for i in alist:
        if alist.count(i) > 1:
            return True
    return False
            
def arePermsEqualParity(perm0, perm1):
    """Check if 2 permutations are of equal parity.

    Assume that both permutation lists are of equal length and have
    the same elements. No need to check for these conditions.

    Thanks to Stackoverflow "how-to-check-if-permutations-have-equal-parity"

    """
    perm1 = perm1[:] ## copy this list so we don't mutate the
                             ## original

    transCount = 0
    for loc in range(len(perm0) - 1): # Do (len - 1) transpositions
        p0 = perm0[loc]
        p1 = perm1[loc]
        if p0 != p1:
            sloc = perm1[loc:].index(p0)+loc          # Find position in perm1
            perm1[loc], perm1[sloc] = p0, p1          # Swap in perm1
            transCount += 1
                            
                            # Even number of transpositions means equal parity
    if (transCount % 2) == 0:
        return True
    else:
        return False
